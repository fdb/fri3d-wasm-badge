<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fri3d Badge Emulator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        h1 {
            margin-bottom: 20px;
            font-size: 24px;
            color: #fff;
        }

        .emulator-container {
            background: #16213e;
            border-radius: 16px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        #canvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            border: 4px solid #0f3460;
            border-radius: 8px;
        }

        .controls {
            margin-top: 20px;
            text-align: center;
            color: #aaa;
            font-size: 14px;
        }

        .controls h3 {
            margin-bottom: 10px;
            color: #fff;
        }

        .key {
            display: inline-block;
            background: #0f3460;
            padding: 4px 8px;
            border-radius: 4px;
            margin: 2px;
            font-family: monospace;
        }

        .loading {
            text-align: center;
            padding: 40px;
        }

        .loading .spinner {
            border: 4px solid #0f3460;
            border-top: 4px solid #e94560;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #output {
            margin-top: 20px;
            padding: 10px;
            background: #0f0f1a;
            border-radius: 8px;
            font-family: monospace;
            font-size: 12px;
            max-height: 150px;
            overflow-y: auto;
            width: 100%;
            max-width: 512px;
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <h1>Fri3d Badge Emulator</h1>

    <div class="emulator-container">
        <div id="loading" class="loading">
            <div class="spinner"></div>
            <p>Loading emulator...</p>
        </div>

        <canvas id="canvas" class="hidden" width="512" height="256"></canvas>

        <div id="controls" class="controls hidden">
            <h3>Controls</h3>
            <p>
                <span class="key">Arrow Keys</span> Navigate
            </p>
            <p>
                <span class="key">Z</span> / <span class="key">Enter</span> Select
            </p>
            <p>
                <span class="key">X</span> / <span class="key">Backspace</span> Back
            </p>
        </div>
    </div>

    <div id="output"></div>

    <script>
        // Fri3d WASM App Runtime
        // Bridges browser's WebAssembly to the C canvas/display code

        const Fri3dRuntime = {
            currentApp: null,
            appMemory: null,
            ready: false,
            animationId: null,
            pendingRequest: null,
            switchInProgress: false,
            launcherPath: '/apps/launcher/launcher.wasm',
            appRegistry: [
                { id: 1, name: 'Circles', path: '/apps/circles/circles.wasm' },
                { id: 2, name: 'Mandelbrot', path: '/apps/mandelbrot/mandelbrot.wasm' },
                { id: 3, name: 'Test Drawing', path: '/apps/test_drawing/test_drawing.wasm' },
                { id: 4, name: 'Test UI', path: '/apps/test_ui/test_ui.wasm' }
            ],

            // Wrapper functions for C++ exports (set after Module loads)
            canvas: null,
            random: null,

            init: function() {
                // Create wrapper functions using cwrap
                this.canvas = {
                    clear: Module.cwrap('js_canvas_clear', null, []),
                    width: Module.cwrap('js_canvas_width', 'number', []),
                    height: Module.cwrap('js_canvas_height', 'number', []),
                    setColor: Module.cwrap('js_canvas_set_color', null, ['number']),
                    setFont: Module.cwrap('js_canvas_set_font', null, ['number']),
                    drawDot: Module.cwrap('js_canvas_draw_dot', null, ['number', 'number']),
                    drawLine: Module.cwrap('js_canvas_draw_line', null, ['number', 'number', 'number', 'number']),
                    drawFrame: Module.cwrap('js_canvas_draw_frame', null, ['number', 'number', 'number', 'number']),
                    drawBox: Module.cwrap('js_canvas_draw_box', null, ['number', 'number', 'number', 'number']),
                    drawRFrame: Module.cwrap('js_canvas_draw_rframe', null, ['number', 'number', 'number', 'number', 'number']),
                    drawRBox: Module.cwrap('js_canvas_draw_rbox', null, ['number', 'number', 'number', 'number', 'number']),
                    drawCircle: Module.cwrap('js_canvas_draw_circle', null, ['number', 'number', 'number']),
                    drawDisc: Module.cwrap('js_canvas_draw_disc', null, ['number', 'number', 'number']),
                    drawStr: Module.cwrap('js_canvas_draw_str', null, ['number', 'number', 'string']),
                    stringWidth: Module.cwrap('js_canvas_string_width', 'number', ['string']),
                };

                this.random = {
                    seed: Module.cwrap('js_random_seed', null, ['number']),
                    get: Module.cwrap('js_random_get', 'number', []),
                    range: Module.cwrap('js_random_range', 'number', ['number']),
                };

                this.displayFlush = Module.cwrap('js_display_flush', null, []);
                this.pollInput = Module.cwrap('js_poll_input', 'number', []);
                this.hasInputEvent = Module.cwrap('js_has_input_event', 'number', []);
                this.getInputEvent = Module.cwrap('js_get_input_event', 'number', []);
                this.getTimeMs = Module.cwrap('js_get_time_ms', 'number', []);

                console.log('Fri3d Runtime initialized');
                console.log('Canvas size:', this.canvas.width(), 'x', this.canvas.height());
                this.ready = true;
            },

            // Read a null-terminated string from WASM memory
            readString: function(ptr) {
                if (!this.appMemory || ptr === 0) return '';
                const bytes = new Uint8Array(this.appMemory.buffer);
                let str = '';
                let i = ptr;
                while (bytes[i] !== 0 && i < bytes.length) {
                    str += String.fromCharCode(bytes[i]);
                    i++;
                }
                return str;
            },

            // Create import object for WASM apps
            createImports: function() {
                const self = this;
                return {
                    env: {
                        canvas_clear: () => self.canvas.clear(),
                        canvas_width: () => self.canvas.width(),
                        canvas_height: () => self.canvas.height(),
                        canvas_set_color: (color) => self.canvas.setColor(color),
                        canvas_set_font: (font) => self.canvas.setFont(font),
                        canvas_draw_dot: (x, y) => self.canvas.drawDot(x, y),
                        canvas_draw_line: (x1, y1, x2, y2) => self.canvas.drawLine(x1, y1, x2, y2),
                        canvas_draw_frame: (x, y, w, h) => self.canvas.drawFrame(x, y, w, h),
                        canvas_draw_box: (x, y, w, h) => self.canvas.drawBox(x, y, w, h),
                        canvas_draw_rframe: (x, y, w, h, r) => self.canvas.drawRFrame(x, y, w, h, r),
                        canvas_draw_rbox: (x, y, w, h, r) => self.canvas.drawRBox(x, y, w, h, r),
                        canvas_draw_circle: (x, y, r) => self.canvas.drawCircle(x, y, r),
                        canvas_draw_disc: (x, y, r) => self.canvas.drawDisc(x, y, r),
                        canvas_draw_str: (x, y, strPtr) => {
                            const str = self.readString(strPtr);
                            self.canvas.drawStr(x, y, str);
                        },
                        canvas_string_width: (strPtr) => {
                            const str = self.readString(strPtr);
                            return self.canvas.stringWidth(str);
                        },
                        random_seed: (seed) => self.random.seed(seed),
                        random_get: () => self.random.get(),
                        random_range: (max) => self.random.range(max),
                        get_time_ms: () => self.getTimeMs(),
                        exit_to_launcher: () => self.requestExitToLauncher(),
                        start_app: (appId) => self.requestStartApp(appId),
                        launch_app: (value) => self.requestLaunchApp(value),
                    }
                };
            },

            requestExitToLauncher: function() {
                this.pendingRequest = { type: 'launcher' };
            },

            requestStartApp: function(appId) {
                this.pendingRequest = { type: 'start_app', appId: appId >>> 0 };
            },

            requestLaunchApp: function(value) {
                const appId = value >>> 0;
                if (this.findAppById(appId)) {
                    this.requestStartApp(appId);
                    return;
                }
                const path = this.readString(value);
                if (path) {
                    this.pendingRequest = { type: 'path', path: path };
                } else {
                    this.log('launch_app: invalid app id or path');
                }
            },

            findAppById: function(appId) {
                return this.appRegistry.find((app) => app.id === appId) || null;
            },

            processPendingRequest: function() {
                if (!this.pendingRequest || this.switchInProgress) {
                    return;
                }

                const request = this.pendingRequest;
                this.pendingRequest = null;

                if (request.type === 'launcher') {
                    this.loadApp(this.launcherPath);
                } else if (request.type === 'start_app') {
                    if (request.appId === 0) {
                        this.loadApp(this.launcherPath);
                        return;
                    }
                    const entry = this.findAppById(request.appId);
                    if (!entry) {
                        this.log('start_app: unknown app id ' + request.appId);
                        this.loadApp(this.launcherPath);
                        return;
                    }
                    this.loadApp(entry.path);
                } else if (request.type === 'path') {
                    this.loadApp(request.path);
                }
            },

            // Load and run a WASM app
            loadApp: async function(path) {
                console.log('Loading app:', path);

                // Stop current app
                this.stopApp();
                this.switchInProgress = true;

                try {
                    // Read file from Emscripten's virtual filesystem
                    const data = FS.readFile(path);
                    const imports = this.createImports();
                    const result = await WebAssembly.instantiate(data, imports);

                    this.currentApp = result.instance;
                    this.appMemory = result.instance.exports.memory;

                    console.log('App loaded successfully');
                    console.log('Exports:', Object.keys(result.instance.exports));

                    // Start render loop
                    this.startRenderLoop();

                } catch (e) {
                    console.error('Failed to load app:', e);
                    this.log('Error loading app: ' + e.message);
                    if (path !== this.launcherPath) {
                        this.requestExitToLauncher();
                    }
                } finally {
                    this.switchInProgress = false;
                }
            },

            startRenderLoop: function() {
                if (this.animationId) {
                    return;
                }
                const self = this;

                function frame() {
                    self.tick();
                    self.animationId = requestAnimationFrame(frame);
                }

                this.animationId = requestAnimationFrame(frame);
            },

            stopApp: function() {
                this.currentApp = null;
                this.appMemory = null;
            },

            tick: function() {
                if (!this.ready) {
                    return;
                }

                // Poll input from SDL
                this.pollInput();

                // Handle input events
                while (this.hasInputEvent()) {
                    const event = this.getInputEvent();
                    if (event >= 0 && this.currentApp && this.currentApp.exports.on_input) {
                        const key = (event >> 8) & 0xFF;
                        const type = event & 0xFF;
                        this.currentApp.exports.on_input(key, type);
                    }
                }

                // Render
                if (this.currentApp && this.currentApp.exports.render) {
                    this.canvas.clear();
                    this.currentApp.exports.render();
                    this.displayFlush();
                }

                this.processPendingRequest();
            },

            log: function(msg) {
                const output = document.getElementById('output');
                output.innerHTML += msg + '<br>';
                output.scrollTop = output.scrollHeight;
            }
        };

        // Emscripten Module configuration
        var Module = {
            canvas: (function() {
                return document.getElementById('canvas');
            })(),
            print: function(text) {
                Fri3dRuntime.log(text);
                console.log(text);
            },
            printErr: function(text) {
                Fri3dRuntime.log('<span style="color: #e94560;">' + text + '</span>');
                console.error(text);
            },
            onRuntimeInitialized: function() {
                document.getElementById('loading').classList.add('hidden');
                document.getElementById('canvas').classList.remove('hidden');
                document.getElementById('controls').classList.remove('hidden');

                // Wait for C++ to initialize (canvas becomes non-zero size)
                function waitForCanvas() {
                    Fri3dRuntime.init();
                    const width = Fri3dRuntime.canvas.width();
                    if (width === 0) {
                        console.log('Waiting for canvas initialization...');
                        setTimeout(waitForCanvas, 100);
                        return;
                    }

                    console.log('Canvas ready:', width, 'x', Fri3dRuntime.canvas.height());

                    // Start with launcher like the desktop emulator
                    Fri3dRuntime.loadApp(Fri3dRuntime.launcherPath);
                }

                waitForCanvas();
            }
        };
    </script>
    {{{ SCRIPT }}}
</body>
</html>
